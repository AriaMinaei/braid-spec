Internet-Draft                                                 M. Toomim
Expires: Mar 8, 2020                                   Invisible College
Intended status: Proposed Standard                           X. Yourname
                                                        Your Affiliation
                                                             Nov 4, 2019

         Braid-Patch: a General Format for Mergeable Operations
                    draft-ietf-httbis-braid-patch-00

Abstract

  A uniform syntax for expressing changes to state.  Allows re-use of
  existing synchronization algorithms and Content-Types.

  Supports arbitrary CRDT or OT algorithms, and most Content-Types.



Status of this Memo

  This Internet-Draft is submitted in full conformance with the
  provisions of BCP 78 and BCP 79.
  
  Internet-Drafts are working documents of the Internet Engineering Task
  Force (IETF), its areas, and its working groups.  Note that other
  groups may also distribute working documents as Internet-Drafts.  The
  list of current Internet-Drafts is at
  http://datatracker.ietf.org/drafts/current/.

  Internet-Drafts are draft documents valid for a maximum of six months
  and may be updated, replaced, or obsoleted by other documents at any
  time.  It is inappropriate to use Internet-Drafts as reference
  material or to cite them other than as "work in progress."

  The list of current Internet-Drafts can be accessed at
  https://www.ietf.org/1id-abstracts.html

  The list of Internet-Draft Shadow Directories can be accessed at
  https://www.ietf.org/shadow.html



Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . 3
   2.  Parser      . . . . . . . . . . . . . . . . . . . . . . . . .  18
   3.  Merger
   4.  Partially-Ordered Content
   5.  Portals to Past Versions
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  23
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  23
   8.  Copyright Notice  . . . . . . . . . . . . . . . . . . . . . .  23
   9.  Author's Address  . . . . . . . . . . . . . . . . . . . . . .  23



1.  Introduction

  Even though there are many synchronization algorithms, making
  different tradeoffs, with different network protocols, it turns out
  that they all need to communicate roughly the same thing -- we can
  re-express their network messages in a single format.

  Braid-Patch is a uniform syntax for changes to state.  Any change is
  expressed in the form:

          "region X of the data was replaced with content Y"

  Synchronization algorithms can be difficult to implement, but the
  Braid-Patch format lets you re-use existing algorithms and
  Content-Types.  To do this, you specify (1) how to PARSE REGIONS from
  the data structure, and (2) how multiple conflicting patches are
  MERGED.

  A Braid-Patch format is thus *composed* of a Parser type and a Merger
  type.  The Parser specifies how to index into subregions of the
  Content-Type, and the Merger specifies how simultaneous patches to the
  same state are merged.

  For instance, here is a patch specification for binary files:

       braid(bytes, sync9(array))
              ^           ^
              |           |
         (1) Parse as    (2) Merge as

  This specifies to (1) interpret a Content-Type as a linear sequence of
  bytes, and to (2) *merge* simultaneous patches using the sync9(array)
  specification.

  Here is a patch following that specification:

       [33:3889] = <binary-data>

  Here is a patch specification for JSON files:

       braid(json, sync9(json))
              ^           ^
              |           |
         (1) Parse as    (2) Merge as

  This specifies to interpret a file as JSON, and merge it using sync9's
  JSON type.

  Here is a patch following that specification:

       .foo.bar[3].baz = {"1": {"two": "tree"}}

  XML files have an isomorphic partial ordering with JSON files.  You
  could conceivably re-use a JSON synchronizer on an XML file by
  converting the XML to JSON, merging the JSON, and then converting the
  result back when necessary.  However, you can do the same thing by
  connecting an XML parser to a JSON merger, since their partial orders
  are compatible:

       braid(xml,  sync9(json))
              ^           ^
              |           |
         (1) Parser    (2) Merger

  Here is a patch following that specification:

       /foo/bar/*[3]/baz = <one two="tree"/>


2.  The Parser

  The Parser is specified as a function, which takes a query string and
  returns a region in the document.  For instance, this is a query
  string that works on the json Parser:

         .foo.bar[3][5].baz

  The regions produced by the Parser have a partial ordering.  This
  partial ordering must be one supported by the Merger type.

  A Parser also specifies how to write a new value for a region into the
  Content, for instance to accept this patch:

         .foo.bar[3][5].baz = "Yesss! New stuff!!!"

3.  The Merger

  The Merger is specified as a function that defines how to merge
  multiple versions together, given complete access to their historical
  braid of patches.

4.  Partially-Ordered Content

  The output of the parser must fit a *partial order* that is supported
  as input to the merger.

  For instance, an array is fully ordered.  But JSON is
  partially-ordered -- it defines an ordering for array elements, and
  characters in a string, but does not define the ordering of keys and
  values in a hash.


5.  Portals to Past Versions

  The normal behavior for a version is that it *creates* some regions,
  and then just *portals* other regions from the previous version.

  However, these *portals* are implicit so far... in a subsequent
  extension, we can make these portals explicit, and remap them amongst
  regions.

  Like, instead of:

        [3:5] = "hello"

  We could explicitly write the copies with portals:

        [:3] = old[:3]
        [3:5] = "hello"
        [5:] = old[5:]


  Portals allow Braid-Patch to directly support:
    - Clones
    - Moves
     - A move is a portal + a delete
    - Ancestral splices
    - Re-orderings (perhaps useful to capture a merge linearization)


6.  Hints

  Escape-valve / failsafe where you can shove data into it if it's
  easier for you to write your code that way.

  So, the overall format of a braid-patch is:

     Patch: "<region> = <value>"     # Required
     Hint: .*                        # Optional

