Internet-Draft                                                 M. Toomim
Expires: Mar 8, 2020                                   Invisible College
Intended status: Proposed Standard                           X. Yourname
                                                        Your Affiliation
                                                             Nov 4, 2019

        :::::::::  :::::::::      :::     ::::::::::: :::::::::  
        :+:    :+: :+:    :+:   :+: :+:       :+:     :+:    :+: 
        +:+    +:+ +:+    +:+  +:+   +:+      +:+     +:+    +:+ 
        +#++:++#+  +#++:++#:  +#++:++#++:     +#+     +#+    +:+ 
        +#+    +#+ +#+    +#+ +#+     +#+     +#+     +#+    +#+ 
        #+#    #+# #+#    #+# #+#     #+#     #+#     #+#    #+# 
        #########  ###    ### ###     ### ########### ######### 

                  Braid HTTP: Synchronization for HTTP
                       draft-ietf-httbis-braid-00

Abstract

  Braid is a set of extensions to HTTP that transform it from a state
  *transfer* protocol into a state *synchronization* protocol.

  Braid adds to HTTP:

     (1) *Subscriptions* to GET requests
     (2) *Versioning* to resources
     (3) *Merge semantics* for PATCH requests

  These extensions enable a web resource to synchronize automatically,
  across multiple clients and servers, and guarantee consistency using a
  OT or CRDT algorithm.




Status of this Memo

  This Internet-Draft is submitted in full conformance with the
  provisions of BCP 78 and BCP 79.
  
  Internet-Drafts are working documents of the Internet Engineering Task
  Force (IETF), its areas, and its working groups.  Note that other
  groups may also distribute working documents as Internet-Drafts.  The
  list of current Internet-Drafts is at
  http://datatracker.ietf.org/drafts/current/.

  Internet-Drafts are draft documents valid for a maximum of six months
  and may be updated, replaced, or obsoleted by other documents at any
  time.  It is inappropriate to use Internet-Drafts as reference
  material or to cite them other than as "work in progress."

  The list of current Internet-Drafts can be accessed at
  https://www.ietf.org/1id-abstracts.html

  The list of Internet-Draft Shadow Directories can be accessed at
  https://www.ietf.org/shadow.html



Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . 3
   1.1.  Use Cases and Related Work
   1.1.1.  Distributed, Peer-to-Peer Web of Data Use Case
   2.  Subscriptions . . . . . . . . . . . . . . . . . . . . . . . .  11
   2.1.  Cache Control
   3.  Versioning  . . . . . . . . . . . . . . . . . . . . . . . . .  15
   4.  Patch Semantics
   5.  Validating Versions and Pruning History
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  23
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  23
   8.  Copyright Notice  . . . . . . . . . . . . . . . . . . . . . .  23
   9.  Author's Address  . . . . . . . . . . . . . . . . . . . . . .  23



1.  Introduction

  When you GET something over HTTP, it gives you the latest version of
  the thing, but it does *not* update you if it changes.  This means
  that programmers have to implement workarounds whenever they need to
  synchronize with data that changes.

  The first workaround was to require the user to reload the page when
  it changed.  In 2000, XMLHTTPRequest made it possible to update just
  part of a page, running a GET request behind the scenes.  But the GET
  request still could not push updates.  To work around this, web
  programmers would poll a resource, which was inefficient.
  Long-polling was invented to overcome the inefficiencies, which was
  standardized as SSE.  But SSE provides semantics of an *event-stream*,
  and although a programmer can encode a protocol within the event
  stream for updating a resource, there is still no standard way to
  update a resource.  In practice, programmers today often give up on
  using a standard semantic for "data that changes", and instead write
  their own idiosyncratic update protocol over a WebSocket, or adopt a
  web framework that does this for them.

  However, we can add support for "state that changes" into HTTP with a
  few small extensions.  Doing so transforms HTTP from a *state
  transfer* protocol into a *state synchronization* protocol, and
  extends the REST architecture into RESS: REpresentational State
  Synchronization.

  We can do this with:

  - An extended *subscribe* for GET: promises to send updates to state
  - Versioning: A common language for time
  - Specification of patch behavior: invariants, semantics, guarantees

  This can be super general:

  - We can even support any OT or CRDT: the most advanced synchronizers

1.1.  Use Cases and Related Work

  - The DAV standards:
    - CalDAV
    - CardDAV
    - WebDAV
  - Email push
    - JMAP
    - IMAP Web Push

1.1.1  Distributed, Peer-to-Peer Web of Data Use Case

  [Feel free to rewrite this from scratch.]

  This also gives us the radical ability to distribute our state --
  across many computers, separated by time and space -- because the
  synchronization algorithm itself collapses spacetime.

  Which enables a whole new radical vision.  We can support
  transclusion, ted nelson's original vision, because you can insert
  part of a document, that lives somewhere else, into a document that
  lives here, and interact with both of them in synchrony.

  We can have data structures that themselves are split amongst multiple
  origin servers, but weaved together in a distributed web.  This is
  what the linked-json format supports.

2.  Subscriptions



2.1.  Cache-Control

3.  Versioning

  Time on a network is ambiguous as a result of latency.  If multiple
  peers edit the same state at the same time, we cannot say that one
  happened before the other, and time forks.  When they communicate
  their changes over the network, they merge their edits, and time
  merges.
 
         (O)    All peers are aware of version (O).
         / \
        /   \
      (A)   (B) Two peers make simultaneous edits creating versions (A)
        \   /   and (B) respectively, and time forks.
         \ /
         (M)    Once a peer sees both of the edits, time merges again.
                Until a peer makes an edit with (A) and (B) as parents,
                the merge is only implicit-- there is no need for to
                assign an ID to it.

  Thus the shape of time is not a line but a Directed Acyclic Graph-- a
  DAG.  Every change to state creates a new version.  This version has
  *parents*: all recent (leaf) versions that the client had seen when it
  made its edit.  The edit becomes the *child* of its parents.  We can
  say that one version came before another only if the first version is
  an *ancestor* of the second.
   
  Every version is identified by a unique ID.  There is no requirement
  on the format of the ID, only that it be a unique string.
  
  When a peer makes an edit, it broadcasts the edit's version ID, its
  parents version IDs, and a patch from its parents state to its state.

  Version+url is immutible.

  Speculative updates.


4.  Patch Semantics

  If you apply patch to old version, you get the new version, that
  should be semantically equivalent to the document.

  You have to be able to recognize duplicate patches (so they are
  idempotent), and also you should be able to see which patches are
  yours in the operation stream.


5.  Validating Versions and Pruning History

Enables:
- Pruning history
- Online & Offline
- Validation

New methods:
- ACK
- DISCONNECTED
- CONNECT
