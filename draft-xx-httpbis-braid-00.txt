Internet-Draft                                                 M. Toomim
Expires: Mar 8, 2020                                   Invisible College
Intended status: Proposed Standard                             G. Little
                                                       Invisible College
                                                               R. Walker
                                                            Bard College
                                                             Nov 4, 2019


        \=/====\\  |//===\\=      /=\     =\==\|\=/== =|====\== 
        ||/    |\\ ||\    |\\   /|| \|\       |//     //|    \\\
        |\\    |// |\\    |//  //|   \\\      \\\     /\/    |||
        \=|====|=  |/====/=\  /=\/====|=\     =\=     \\=    =/=
        //\    /\\ //|    |\\ |/|     |||     \\\     |||    |//
        |||    ||| |\\    |// |\/     \|/     /|\     |=\    |\\
        =\=\==/=/  ==|    |\= ||=     /== ===/=|=\=== |==\===// 

                  Braid-HTTP: Synchronization for HTTP
                       draft-ietf-httbis-braid-00

Abstract

  Braid is a set of extensions to HTTP that transform it from a state
  *transfer* protocol into a state *synchronization* protocol.

  Braid adds to HTTP:

     1. *Subscriptions* to GET requests
     2. *Versioning* to resources
     3. *Semantics* to PATCH requests
     4. *Multi-party Acknowledgements* to validate and prune history

  These extensions enable a web resource to synchronize automatically,
  across multiple clients and servers, and guarantee consistency using a
  OT or CRDT algorithm.




Status of this Memo

  This Internet-Draft is submitted in full conformance with the
  provisions of BCP 78 and BCP 79.
  
  Internet-Drafts are working documents of the Internet Engineering Task
  Force (IETF), its areas, and its working groups.  Note that other
  groups may also distribute working documents as Internet-Drafts.  The
  list of current Internet-Drafts is at
  http://datatracker.ietf.org/drafts/current/.

  Internet-Drafts are draft documents valid for a maximum of six months
  and may be updated, replaced, or obsoleted by other documents at any
  time.  It is inappropriate to use Internet-Drafts as reference
  material or to cite them other than as "work in progress."

  The list of current Internet-Drafts can be accessed at
  https://www.ietf.org/1id-abstracts.html

  The list of Internet-Draft Shadow Directories can be accessed at
  https://www.ietf.org/shadow.html



Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . 3
   1.1.  Design Goals
   1.2.  Use Cases and Related Work
   1.2.1  Example: a Serverless Chat
   2.  Subscriptions for GET   . . . . . . . . . . . . . . . . . . .  11
   2.1.  Creating a Subscription
   2.2.  Sending multiple updates per GET
   2.3.  Continuing a Subscription
   2.4.  Ending a Subscription
   2.5.  Example: GET subscription to animated gif
   3.  Versioning  . . . . . . . . . . . . . . . . . . . . . . . . .  15
   4.  Patch Semantics
   4.1.  Cache Control
   5.  Validating Versions and Pruning History
   5.2. The FISSURE method
   5.3. The MULTISET method
   5.4. The ACK method
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  23
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  23
   8.  Copyright Notice  . . . . . . . . . . . . . . . . . . . . . .  23
   9.  Author's Address  . . . . . . . . . . . . . . . . . . . . . .  23



1.  Introduction

  When a client GETs a resource over HTTP, the server provides the
  latest version, but does *not* provide updates when the resource
  changes.  This means that programmers have to implement workarounds
  whenever they need to synchronize with data that changes.

  The web used to require users to click reload when a page changed.  In
  2000, XMLHTTPRequest made it possible to update just part of a page,
  running a GET request behind the scenes.  But a GET request still
  could not push updates.  To work around this, web programmers would
  poll the resource, which was inefficient.  Long-polling was invented
  to overcome the inefficiencies, which was standardized as SSE.  But
  SSE provides semantics of an *event-stream*, and although a programmer
  can encode a protocol within the event stream for updating a resource,
  there is still no standard way to express the update of a resource.
  In practice, programmers today often give up on using a standard
  semantic for "data that changes", and instead write their own
  idiosyncratic update protocol over a WebSocket, or adopt a web
  framework that does this for them.

  This document specifies how to add support for "state that changes" to
  HTTP with a few small extensions.  Doing so transforms HTTP from a
  *state transfer* protocol into a *state synchronization* protocol, and
  extends the REST architecture into RESS: REpresentational State
  Synchronization.



1.1.  Design Goals

  This spec is designed to be easy to implement, while also supporting
  full Operational Transform and CRDT synchronization algorithms.

1.2.  Use Cases and Related Work

  - The DAV standards:
    - CalDAV
    - CardDAV
    - WebDAV
  - W3C Push API: https://www.w3.org/TR/push-api/
  - Email push
    - JMAP
    - IMAP Web Push

1.2.1  Example: a Serverless Chat

  A Braid web application can operate offline.  Multiple users can use
  the app from an airplane, and their edits will synchronize when they
  regain internet connections.  Additionally, the Braid protocol can be
  expressed on a peer-to-peer transport (e.g. Braid-WebRTC) to support a
  peer-to-peer synchronization without a server.  Braid-HTTP clients can
  interoperate with Braid-WebRTC peers.  Thus, a chat application, for
  instance, could be served and synchronized over Braid-HTTP, with
  redundant peer-to-peer connections established using Braid-WebRTC.
  The server could then be shut down, and users of the chat app could
  continue to send messages to one another.

  Imagine the server serves the current set of trusted clients' IP
  addresses at the /peers state.  Each client then subscribes to the
  /peers state with:

      GET /peers
      Subscribe: keep-alive
      -------
      [ {ip: '13.55.32.158', pubkey: 'x371...8382'}
        {ip: '244.38.55.83', pubkey: 'o2u8...2s73'},
        ...
      ]

  Each peer can then choose some of those peers at random to establish a
  WebRTC connection with.  It will then send Braid messages to that peer
  over that connection.


2.  Subscriptions for GET

  A Braid client requests a subscription by issuing a GET with the
  Subscribe header.  A server that implements subscriptions promises to
  keep its subscribed clients up-to-date by sending changes until the
  client closes the subscription.

  A subscription is different than a GET connection (e.g. a TCP
  connection, or HTTP/2 stream).  A subscription marked keep-alive will
  remembered even after the GET is closed, and can be continued by the
  client issuing another GET with a Subscribe header.

2.1.  Creating a Subscription

  A client MAY request a subscription by issuing a GET request
  containing a Subscribe header:

          Subscribe
     or   Subscribe: keep-alive
     or   Subscribe: keep-alive=<seconds>

  If a server implements Subscribe, it MUST include a Subscribe header
  in its response.  The server then SHOULD keep the connection open, so
  it can send the client updates over the connection.

2.2.  Sending multiple updates per GET

  To send multiple updates, a server concatenates multiple sub-responses
  into a single response body.  Each sub-response MUST contain its own
  headers and body.  Each sub-response's headers MUST contain a

          Content-Length: N

  header, where N is specified in bytes, and its body MUST be exactly N
  bytes, followed by a single newline.  Any data following this newline
  begins the next sub-response's header.

  Each response MUST have both headers and a body.  The body MAY be
  zero-length.

2.3.  Continuing a Subscription

  If a server responds with

          Subscribe: keep-alive
      or  Subscribe: keep-alive=<seconds>

  Then it SHOULD keep the subscription open even after the GET request's
  connection closes.  This means that the server promises to keep enough
  history to merge with the client when the client comes back online.

  When the client reconnects, it MAY specify the most recent versions it
  saw from the server using the Parents header (Section 3).  This tells
  the server which versions of state to catch it up from.

  The server can suggest how long it will wait for the client by
  responding with Subscribe: keep-alive=<seconds>.  A server SHOULD wait
  at least <seconds> after a connection closes before dropping the
  subscription, and clearing its history.

2.4.  Ending a Subscription

  Servers and clients MAY drop a subscription at any time, no matter the
  value of keep-alive.  A client MAY reconnect by issuing a new GET
  request with a new Subscribe header.

  If a subscription is set to keep-alive, then closing the TCP/QUIC
  connection won't end the subscription.  Thus a client needs a way to
  explicitly end the subscription.  In HTTP/1, this is by sending the
  text "Forget\n" over the TCP connection.  In HTTP/2, this is by
  issuing a CLOSE event to the GET request's stream.  Alternatively,
  since today's web browsers do not support sending extra text after a
  request body, the client can issue a fresh request specified as a
  FORGET method.


2.5.  Example: GET subscription to animated gif

  Request:
      GET /animated-braid.gif
      Subscribe

  Response:
      OK 200
      Subscribe
      Cache-Control: no-cache
      Patch-Type: braid-patch(bytes, sync9(array))

      Content-Type: image/gif                             -- Part 1
      Patch-Type: braid-patch(bytes, sync9(array))
      Content-Length: 1239

      [100:200] = <binary data>

      Content-Type: image/gif                             -- Part 2
      Patch-Type: braid-patch(bytes, sync9(array))
      Content-Length: 62638

      [348:887] = <binary data>

2.6.  Errors

  XX Todo: What happens if the server decides to drop the history that a
           client asks for?  How does it tell the client "sorry, I don't
           have the history to synchronize with you."

3.  Versioning

  Time on a network is ambiguous as a result of latency.  If multiple
  peers edit the same state at the same time, we cannot say that one
  happened before the other, and time forks.  When they communicate
  their changes over the network, they merge their edits, and time
  merges.
 
          a     All peers are aware of version (a).
         / \
        /   \
       b     c  Two peers make simultaneous edits creating versions (b)
        \   /   and (c) respectively, and time forks.
         \ /
          d     Once a peer sees both of the edits, time merges again.
                Until a peer makes an edit with (b) and (c) as parents,
                the merge is only implicit-- there is no need for to
                assign an ID to it.

  Thus the shape of time is not a line but a Directed Acyclic Graph-- a
  DAG.  Every change to state creates a new version.  This version has
  *parents*: all recent (leaf) versions that the client had seen when it
  made its edit.  The edit becomes the *child* of its parents.  We can
  say that one version came before another only if the first version is
  an *ancestor* of the second.
   
  Every version is identified by a unique ID.  There is no requirement
  on the format of the ID, only that it be a unique string.
  
  When a peer makes an edit, it broadcasts the edit's version ID, its
  parents version IDs, and a patch from its parents state to its state.

  Version+url is immutible.


4.  Patch Semantics

  You can patch witih either PATCH or PUT.  Just keep in mind that PATCH
  is not idempotent.  We recommend using PUT if you specify a version &
  parents.

  You add a

      Patch-Type: <patch-type>

  header to your PUT.  This defines the format of patches, and the
  behavior of merging them together.

  A patch-type can be defined separately.  It SHOULD satisfy:

     1.  If a set of patches originated from a version, and you apply
         them to a copy of the version, you get the same new version
         again.

  It MAY satisfy:

     2.  (Commute) If the same set of patches are applied in a different
         order, the result is the same.

  Example:

      Patch-Type: braid-patch(json, sync9(json))



4.1.  Cache-Control

  Servers and clients can choose whether to send a state update as a
  full resource, or just a patch.  If sent as a patch, the request and
  response headers should contain:

      Cache-Control: no-cache, patch

  so that legacy caches do not try to store the patch.  However, any
  cache that implements the given Patch-Type MUST ignore the no-cache
  directive if the patch directive is present.

5.  Validating Versions and Pruning History

  A client or server does not need to implement any of the methods in
  this section unless they want to participate in a validation network,
  or be able to provably prune history without breaking subscriptions.

5.2. The FISSURE method

  A Fissure occurs whenever a connection between two peers is broken.

  When a server receives a FISSURE message, it will incorporate this
  fissure information into itself, and if it hasn't seen it already, it
  will also repeat the message to all other peers.

  A fissure represents a disconnection between two peers.  In fact, each
  disconnection creates two fissure objects, one on each side of the
  disconnection.  These fissure objects share a fissure id, but have
  opposite Side-A and Side-B.  A fissure object also has a list of
  versions which were not globally acknowledged at the time of the
  fissure. Note that these versions may be different between the two
  fissure objects associated with the same disconnection event.  Each
  fissure object also has a list of parent fissure ids, which represent
  the other fissures known at the time of this fissure.

    FISSURE
        From-Peer: "xyz"                // peer id
        Id: "xyz"                       // fissure id
        Side-A: "xyz"                   // peer id
        Side-B: "xyz"                   // peer id
        Versions: ["xyz", "xyz", ...]   // array of version ids to keep
        Parents: ["xyz", "xyz", ...]    // array of fissure ids

  The fissure information is used when pruning.  The basic idea is this:
  if a version is within the version set of some fissure, then it may
  not be pruned.  When can we prune it then?  Well, we must first prune
  the fissure, and we can prune a fissure if we become aware of both
  sides of the fissure (the two fissure objects with the same id, but
  opposite Side-A and Side-B), and also we are not aware of any fissures
  which are children of this fissure.  Once the fissure is gone, we can
  prune the versions that it was protecting, as well as possibly prune
  other fissures that this fissure was a child of.
    

5.3. The MULTISET method

  There are two kinds of MULTISET:

  1. Initial MULTISET, sent in response to GET.

     This MULTISET does not contain Min-Leaves or Max-Leaves. When a
     peer receives an initial MULTISET, it will consume it, and send a
     new MULTISET to all its other peers. The new MULTISET will only
     contain the versions and fissures that were new to this
     peer. Also, it will send Min-Leaves and Max-Leaves, where
     Min-Leaves is a list of the leaves of the set intersection of this
     peer's versions with the incoming versions, and Max-Leaves is a
     list of the leaves of the set union.

  2. Non-initial MULTISET, sent in response to MULTISET

     This MULTISET does contain Min-Leaves and Max-Leaves. When a peer
     receives such a MULTISET, it will consume it, and send a new
     MULTISET to all its other peers just like above, except that it
     won't calculate a new Min-Leaves and Max-Leaves, it will just
     forward the values it receives for these.

  The purpose of Min-Leaves is to tell everyone to
  un-globally-acknowledge anything newer than these versions (since
  these versions are no longer globally acknowledged given that this
  newcommer hasn't heard of them yet).  The purpose of Max-Leaves is to
  tell everyone to ignore any in-flight global acknowledgements for any
  versions within Max-Leaves, meaning the system will wait for a version
  newer than Max-Leaves to become globally acknowledged in order to know
  that it has been acknowledged by this newcommer as well.
    
    MULTISET key
        From-Peer: "xyz"                // peer id
        Versions: [{version_id, parents, patches}, ...]
        Fissures: [{fissure_id, side_a, side_b, versions, parents}, ...]
        Min-Leaves: ["xyz", "xyz", ...] // leaves of intersection
        Max-Leaves: ["xyz", "xyz", ...] // leaves of union

5.4. The ACK method

  There are two kinds of ACK:

  1. ACK Seen:

     If a peer creates a version, then it SHOULD send a SET to all its
     peers, and wait for an ACK Seen "local" or a SET with the same
     version id from each peer before then sending an ACK Seen "global"
     to all its peers.

     If a peer receives a version initially from a SET, then it SHOULD
     send a SET to all other peers, and wait for an ACK Seen "local" or
     a SET with the same version id from each of these peers before
     sending an ACK Seen "local" back to the peer that sent the initial
     SET.

     If a peer receives an ACK Seen "global", and this is new
     information, then it SHOULD send an ACK Seen "global" to all its
     other peers.

  2. ACK Valid:

     ACK key
         From-Peer: "xyz"                // peer id
         Seen: "local" | "global"
         Valid: "local" | "global" | "abort"
         Version: "xyz"                  // version being acknowledged

5.4.1.  Example: Using validation to enable speculative edits


6. Security Considerations

  XXX Todo


7. IANA Considerations

  XXX Todo


8. Copyright Notice

  Copyright (c) 2019 IETF Trust and the persons identified as the
  document authors.  All rights reserved.

  This document is subject to BCP 78 and the IETF Trust's Legal
  Provisions Relating to IETF Documents
  (http://trustee.ietf.org/license-info) in effect on the date of
  publication of this document.  Please review these documents
  carefully, as they describe your rights and restrictions with respect
  to this document.  Code Components extracted from this document must
  include Simplified BSD License text as described in Section 4.e of the
  Trust Legal Provisions and are provided without warranty as described
  in the Simplified BSD License.


9. Author's Address

  Michael Toomim
  Invisible College, Berkeley
  Email: toomim@gmail.com
  Web:   https://invisible.college/@toomim

  Greg Little
  Invisible College, Berkeley
  Email: toomim@gmail.com
  Web:   https://glittle.org/

  Rafie Walker
  Bard College
  Email: slickytail.mc@gmail.com
