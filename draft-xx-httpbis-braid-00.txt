Internet-Draft                                                 M. Toomim
Expires: Mar 8, 2020                                   Invisible College
Intended status: Proposed Standard                           X. Yourname
                                                        Your Affiliation
                                                             Nov 4, 2019

        :::::::::  :::::::::      :::     ::::::::::: :::::::::  
        :+:    :+: :+:    :+:   :+: :+:       :+:     :+:    :+: 
        +:+    +:+ +:+    +:+  +:+   +:+      +:+     +:+    +:+ 
        +#++:++#+  +#++:++#:  +#++:++#++:     +#+     +#+    +:+ 
        +#+    +#+ +#+    +#+ +#+     +#+     +#+     +#+    +#+ 
        #+#    #+# #+#    #+# #+#     #+#     #+#     #+#    #+# 
        #########  ###    ### ###     ### ########### ######### 

                  Braid HTTP: Synchronization for HTTP
                       draft-ietf-httbis-braid-00

Abstract

  Braid is a set of extensions to HTTP that transform it from a state
  *transfer* protocol into a state *synchronization* protocol.

  Braid adds to HTTP:

     (1) *Subscriptions* to GET requests
     (2) *Versioning* to resources
     (3) *Consistency guarantees* to PATCH semantics

  These extensions enable a web resource to synchronize automatically,
  across multiple clients and servers, and guarantee consistency using a
  OT or CRDT algorithm.




Status of this Memo

  This Internet-Draft is submitted in full conformance with the
  provisions of BCP 78 and BCP 79.
  
  Internet-Drafts are working documents of the Internet Engineering Task
  Force (IETF), its areas, and its working groups.  Note that other
  groups may also distribute working documents as Internet-Drafts.  The
  list of current Internet-Drafts is at
  http://datatracker.ietf.org/drafts/current/.

  Internet-Drafts are draft documents valid for a maximum of six months
  and may be updated, replaced, or obsoleted by other documents at any
  time.  It is inappropriate to use Internet-Drafts as reference
  material or to cite them other than as "work in progress."

  The list of current Internet-Drafts can be accessed at
  https://www.ietf.org/1id-abstracts.html

  The list of Internet-Draft Shadow Directories can be accessed at
  https://www.ietf.org/shadow.html



Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . 3
   1.1.  Use Cases and Related Work
   1.1.1.  Use Case: a Serverless Chat
   2.  Subscriptions for GET   . . . . . . . . . . . . . . . . . . .  11
   2.1.  Creating a Subscription
   2.2.  Ending a Subscription
   2.3. Forgetting a subscription with the FORGET method
   3.  Versioning  . . . . . . . . . . . . . . . . . . . . . . . . .  15
   4.  Patch Semantics
   4.1.  Cache Control
   5.  Validating Versions and Pruning History
   5.2. The FISSURE method
   5.3. The MULTISET method
   5.4. The ACK method
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  23
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  23
   8.  Copyright Notice  . . . . . . . . . . . . . . . . . . . . . .  23
   9.  Author's Address  . . . . . . . . . . . . . . . . . . . . . .  23



1.  Introduction

  When you GET something over HTTP, it gives you the latest version of
  the thing, but it does *not* update you if it changes.  This means
  that programmers have to implement workarounds whenever they need to
  synchronize with data that changes.

  The original workaround was to require the user to reload the page
  when it changed.  Then in 2000, XMLHTTPRequest made it possible to
  update just part of a page, running a GET request behind the scenes.
  But the GET request still could not push updates.  To work around
  this, web programmers would poll the resource, which was inefficient.
  Long-polling was invented to overcome the inefficiencies, which was
  standardized as SSE.  But SSE provides semantics of an *event-stream*,
  and although a programmer can encode a protocol within the event
  stream for updating a resource, there is still no standard way to
  update a resource.  In practice, programmers today often give up on
  using a standard semantic for "data that changes", and instead write
  their own idiosyncratic update protocol over a WebSocket, or adopt a
  web framework that does this for them.

  However, we can add support for "state that changes" into HTTP with a
  few small extensions.  Doing so transforms HTTP from a *state
  transfer* protocol into a *state synchronization* protocol, and
  extends the REST architecture into RESS: REpresentational State
  Synchronization.

  We can do this with:

  - An extended *subscribe* for GET: promises to send updates to state
  - Versioning: A common language for time
  - Specification of patch behavior: invariants, semantics, guarantees

  This should be super general:

  - Simple cases, like subscribing to the state of a video game
    controller, should be so simple you would not mind writing it by
    hand.
  - But also support the cutting-edge technology.
    - This spec can support any OT or CRDT.

1.1.  Use Cases and Related Work

  - The DAV standards:
    - CalDAV
    - CardDAV
    - WebDAV
  - Email push
    - JMAP
    - IMAP Web Push

1.1.1  Use Case: a Serverless Chat

  Imagine a chat web app.

  Imagine the server serves the current set of trusted clients' ip
  addresses at the /peers state.  And thus each client runs Javascript
  that does a:

      GET /peers
      Subscribe: keep-open
      -------
      [ {ip: '13.55.32.158', pubkey: 'x371...8382'}
        {ip: '244.38.55.83', pubkey: 'o2u8...2s73'},
        ...
      ]

  Then each peer chooses some of those peers at random, establishes
  WebRTC connection with them, and sends Braid messages to that peer
  over that connection.  (Not necessarily Braid-HTTP, but sending the
  same semantics.)

  If the peers treat the peers just like a server, except for
  transporting the messages over WebRTC instead of HTTP, then they will
  not need the server beyond the initial bootstrap phase.  You can shut
  off the server, and the app can continue running, with people able to
  chat with one another.

2.  Subscriptions for GET

  The goal is for GET to semantically update the resource.  We use a
  mechanism syntactically like SSE (a single GET is kept open, and
  updates are streamed over it.), but with "update-resource" semantics.

  Caches and proxies can synchronize with changing content, and clients
  can connect to them, and synchronize.  They can even catch up
  partially, however much they are behind.

2.1.  Creating a Subscription

  A client MAY request a subscription by issuing a GET request
  containing a Subscribe header:

          Subscribe:
  or      Subscribe: keep-open
  or      Subscribe: keep-open=<seconds>

  Subscribe means go into the special mode.  This mode keeps the
  connection open, and sends multiple responses to a single request.
  Each response indicates how long it is with the

       Content-Length: N Bytes

  header.  Any text arriving after N bytes (including the length of the
  header) begins the next response message.

  Each response MUST have both headers and a body, just like a normal
  response.

2.2.  Ending a Subscription

  If the request lacks "Subscribe: keep-open", then the subscription
  ends when the connection closes.  However, if "Subscribe: keep-open",
  and the server acknowledges "Subscribe: keep-open" in its own
  response, then the server will keep the subscription active, which
  means it promises to keep enough history to merge with the client when
  the client comes back online.

  The server can also return "Subscribe: keep-open=<seconds>" instead of
  "Subscribe: keep-open", which is a suggestion of how long it will keep
  the history for the client, after a connection has ended.

  Servers and clients MAY drop a subscription at any time, no matter
  what the value of keep-open.  A client MAY reconnect to establish a
  new subscription, by issuing a new GET request with a new Subscribe
  header.

  If a subscription is set to keep-open, then simply closing a
  connection won't end the subscription.  Thus a client needs a way to
  explicitly end the subscription.  In HTTP/1, this is by sending the
  text "Forget\n" over the TCP connection.  In HTTP/2, this is by
  issuing a CLOSE event to the GET request's stream.


3.  Versioning

  Time on a network is ambiguous as a result of latency.  If multiple
  peers edit the same state at the same time, we cannot say that one
  happened before the other, and time forks.  When they communicate
  their changes over the network, they merge their edits, and time
  merges.
 
         (O)    All peers are aware of version (O).
         / \
        /   \
      (A)   (B) Two peers make simultaneous edits creating versions (A)
        \   /   and (B) respectively, and time forks.
         \ /
         (M)    Once a peer sees both of the edits, time merges again.
                Until a peer makes an edit with (A) and (B) as parents,
                the merge is only implicit-- there is no need for to
                assign an ID to it.

  Thus the shape of time is not a line but a Directed Acyclic Graph-- a
  DAG.  Every change to state creates a new version.  This version has
  *parents*: all recent (leaf) versions that the client had seen when it
  made its edit.  The edit becomes the *child* of its parents.  We can
  say that one version came before another only if the first version is
  an *ancestor* of the second.
   
  Every version is identified by a unique ID.  There is no requirement
  on the format of the ID, only that it be a unique string.
  
  When a peer makes an edit, it broadcasts the edit's version ID, its
  parents version IDs, and a patch from its parents state to its state.

  Version+url is immutible.


4.  Patch Semantics

  If you apply patch to old version, you get the new version, that
  should be semantically equivalent to the document.

  You have to be able to recognize duplicate patches (so they are
  idempotent), and also you should be able to see which patches are
  yours in the operation stream.


4.1.  Cache-Control

  Servers and clients can choose whether to send a state update as a full
  resource, or just a patch.  If it uses a patch, the 

      Cache-Control: no-cache

  so that existing proxies/caches don't try to store it, without knowing
  the patch semantics.

5.  Validating Versions and Pruning History


5.2. The FISSURE method

  When a server receives a FISSURE message, it will incorporate this
  fissure information into itself, and if it hasn't seen it already, it
  will also repeat the message to all other peers.

  A fissure represents a disconnection between two peers.  In fact, each
  disconnection creates two fissure objects, one on each side of the
  disconnection.  These fissure objects share a fissure id, but have
  opposite Side-A and Side-B.  A fissure object also has a list of
  versions which were not globally acknowledged at the time of the
  fissure. Note that these versions may be different between the two
  fissure objects associated with the same disconnection event.  Each
  fissure object also has a list of parent fissure ids, which represent
  the other fissures known at the time of this fissure.

    FISSURE
        From-Peer: "xyz"                // peer id
        Id: "xyz"                       // fissure id
        Side-A: "xyz"                   // peer id
        Side-B: "xyz"                   // peer id
        Versions: ["xyz", "xyz", ...]   // array of version ids to keep
        Parents: ["xyz", "xyz", ...]    // array of fissure ids

  The fissure information is used when pruning.  The basic idea is this:
  if a version is within the version set of some fissure, then it may
  not be pruned.  When can we prune it then?  Well, we must first prune
  the fissure, and we can prune a fissure if we become aware of both
  sides of the fissure (the two fissure objects with the same id, but
  opposite Side-A and Side-B), and also we are not aware of any fissures
  which are children of this fissure.  Once the fissure is gone, we can
  prune the versions that it was protecting, as well as possibly prune
  other fissures that this fissure was a child of.
    

5.3. The MULTISET method

  There are two kinds of MULTISET:

  1. Initial MULTISET, sent in response to GET.

     This MULTISET does not contain Min-Leaves or Max-Leaves. When a
     peer receives an initial MULTISET, it will consume it, and send a
     new MULTISET to all its other peers. The new MULTISET will only
     contain the versions and fissures that were new to this
     peer. Also, it will send Min-Leaves and Max-Leaves, where
     Min-Leaves is a list of the leaves of the set intersection of this
     peer's versions with the incoming versions, and Max-Leaves is a
     list of the leaves of the set union.

  2. Non-initial MULTISET, sent in response to MULTISET

     This MULTISET does contain Min-Leaves and Max-Leaves. When a peer
     receives such a MULTISET, it will consume it, and send a new
     MULTISET to all its other peers just like above, except that it
     won't calculate a new Min-Leaves and Max-Leaves, it will just
     forward the values it receives for these.

  The purpose of Min-Leaves is to tell everyone to
  un-globally-acknowledge anything newer than these versions (since
  these versions are no longer globally acknowledged given that this
  newcommer hasn't heard of them yet).  The purpose of Max-Leaves is to
  tell everyone to ignore any in-flight global acknowledgements for any
  versions within Max-Leaves, meaning the system will wait for a version
  newer than Max-Leaves to become globally acknowledged in order to know
  that it has been acknowledged by this newcommer as well.
    
    MULTISET key
        From-Peer: "xyz"                // peer id
        Versions: [{version_id, parents, patches}, ...]
        Fissures: [{fissure_id, side_a, side_b, versions, parents}, ...]
        Min-Leaves: ["xyz", "xyz", ...] // leaves of intersection
        Max-Leaves: ["xyz", "xyz", ...] // leaves of union

5.4. The ACK method

  There are two kinds of ACK:

  1. ACK Seen:

     If a peer creates a version, then it SHOULD send a SET to all its
     peers, and wait for an ACK Seen "local" or a SET with the same
     version id from each peer before then sending an ACK Seen "global"
     to all its peers.

     If a peer receives a version initially from a SET, then it SHOULD
     send a SET to all other peers, and wait for an ACK Seen "local" or
     a SET with the same version id from each of these peers before
     sending an ACK Seen "local" back to the peer that sent the initial
     SET.

     If a peer receives an ACK Seen "global", and this is new
     information, then it SHOULD send an ACK Seen "global" to all its
     other peers.

  2. ACK Valid:

     ACK key
         From-Peer: "xyz"                // peer id
         Seen: "local" | "global"
         Valid: "local" | "global" | "abort"
         Version: "xyz"                  // version being acknowledged

5.4.1.  Example: Using validation to enable speculative edits

