Internet-Draft                                                 M. Toomim
Expires: Mar 8, 2020                                   Invisible College
Intended status: Proposed Standard                           X. Yourname
                                                        Your Affiliation
                                                             Nov 4, 2019

        :::::::::  :::::::::      :::     ::::::::::: :::::::::  
        :+:    :+: :+:    :+:   :+: :+:       :+:     :+:    :+: 
        +:+    +:+ +:+    +:+  +:+   +:+      +:+     +:+    +:+ 
        +#++:++#+  +#++:++#:  +#++:++#++:     +#+     +#+    +:+ 
        +#+    +#+ +#+    +#+ +#+     +#+     +#+     +#+    +#+ 
        #+#    #+# #+#    #+# #+#     #+#     #+#     #+#    #+# 
        #########  ###    ### ###     ### ########### ######### 

                  Braid HTTP: Synchronization for HTTP
                       draft-ietf-httbis-braid-00

Abstract

  Braid is a set of extensions to HTTP that transform it from a state
  *transfer* protocol into a state *synchronization* protocol.

  Braid adds to HTTP:

     (1) *Subscriptions* to GET requests
     (2) *Versioning* to resources
     (3) *Merge semantics* for PATCH requests

  These extensions enable a web resource to synchronize automatically,
  across multiple clients and servers, and guarantee consistency using a
  OT or CRDT algorithm.




Status of this Memo

  This Internet-Draft is submitted in full conformance with the
  provisions of BCP 78 and BCP 79.
  
  Internet-Drafts are working documents of the Internet Engineering Task
  Force (IETF), its areas, and its working groups.  Note that other
  groups may also distribute working documents as Internet-Drafts.  The
  list of current Internet-Drafts is at
  http://datatracker.ietf.org/drafts/current/.

  Internet-Drafts are draft documents valid for a maximum of six months
  and may be updated, replaced, or obsoleted by other documents at any
  time.  It is inappropriate to use Internet-Drafts as reference
  material or to cite them other than as "work in progress."

  The list of current Internet-Drafts can be accessed at
  https://www.ietf.org/1id-abstracts.html

  The list of Internet-Draft Shadow Directories can be accessed at
  https://www.ietf.org/shadow.html



Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . 3
   2.  Subscriptions . . . . . . . . . . . . . . . . . . . . . . . .  11
   3.  Versioning  . . . . . . . . . . . . . . . . . . . . . . . . .  15
   4.  Merge Semantics
   2.3.  Patches     . . . . . . . . . . . . . . . . . . . . . . . .  17
   2.3.1.  A general patch format
   2.3.  Cache-Control
   4.4.4.  Acknowledgements  . . . . . . . . . . . . . . . . . . . .  19
   5.  Related work
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  23
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  23
   8.  Copyright Notice  . . . . . . . . . . . . . . . . . . . . . .  23
   9.  Author's Address  . . . . . . . . . . . . . . . . . . . . . .  23



1.  Introduction

  HTTP is designed to transfer static pages.  If a page changes, it is
  the client's responsibility to issue another GET request.

  Although this model worked well for many years, websites now serve and
  receive realtime data, synchronizing the state of an app across
  multiple users.  This realtime state cannot be shared on HTTP, without
  resorting to workarounds like writing a custom protocol on a Websocket
  or implementing long-polling HTTP requests.

  Furthermore, 

  This made
  sense when pages were static and written by hand.  However, today's
  websites are dynamic, generated from databases, and continuously
  mutate as their state changes.  Now we need state *synchronization*,
  not just state *transfer*.

  Unfortunately, there is no standard way to synchronize.  Instead,
  programmers write non-standard code; wiring together custom protocols
  over WebSockets and long-polling XMLHTTPrequests with stacks of
  Javascript frameworks.  The task of connecting a UI with data is one
  that every dynamic website has to do, but there is no standard way to
  do it.

1.1.  Use Cases
 

1.2.  Invariants

  Version+url is immutible.

  If you apply patch to old version, you get the new version, that
  should be semantically equivalent to the document.

  You have to be able to recognize duplicate patches (so they are
  idempotent), and also you should be able to see which patches are
  yours in the operation stream.

  Speculative updates.


2.  Subscriptions


3.  Versioning

  Time on a network is ambiguous as a result of latency.  If multiple
  peers edit the same state at the same time, we cannot say that one
  happened before the other, and time forks.  When they communicate
  their changes over the network, they merge their edits, and time
  merges.
 
         (O)    All peers are aware of version (O).
         / \
        /   \
      (A)   (B) Two peers make simultaneous edits creating versions (A)
        \   /   and (B) respectively, and time forks.
         \ /
         (M)    Once a peer sees both of the edits, time merges again.
                Until a peer makes an edit with (A) and (B) as parents,
                the merge is only implicit-- there is no need for to
                assign an ID to it.

  Thus the shape of time is not a line but a Directed Acyclic Graph-- a
  DAG.  Every change to state creates a new version.  This version has
  *parents*: all recent (leaf) versions that the client had seen when it
  made its edit.  The edit becomes the *child* of its parents.  We can
  say that one version came before another only if the first version is
  an *ancestor* of the second.
   
  Every version is identified by a unique ID.  There is no requirement
  on the format of the ID, only that it be a unique string.
  
  When a peer makes an edit, it broadcasts the edit's version ID, its
  parents version IDs, and a patch from its parents state to its state.


5.  Related Work

- WebDAV