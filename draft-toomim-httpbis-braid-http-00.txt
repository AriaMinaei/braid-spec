Internet-Draft                                                 M. Toomim
Expires: Mar 8, 2020                                   Invisible College
Intended status: Proposed Standard                             G. Little
                                                       Invisible College
                                                               R. Walker
                                                            Bard College
                                                              B. Bellomy
                                                       Invisible College
                                                             Nov 4, 2019

        \=/====\\  |//===\\=      /=\     =\==\|\=/== =|====\==
        ||/    |\\ ||\    |\\   /|| \|\       |//     //|    \\\
        |\\    |// |\\    |//  //|   \\\      \\\     /\/    |||
        \=|====|=  |/====/=\  /=\/====|=\     =\=     \\=    =/=
        //\    /\\ //|    |\\ |/|     |||     \\\     |||    |//
        |||    ||| |\\    |// |\/     \|/     /|\     |=\    |\\
        =\=\==/=/  ==|    |\= ||=     /== ===/=|=\=== |==\===//

                  Braid-HTTP: Synchronization for HTTP
                   draft-toomim-httpbis-braid-http-00

Abstract

   Braid is a set of extensions to HTTP that transform it from a state
   transfer protocol into a state synchronization protocol.

   Braid adds to HTTP:

     1. Versioning to resources
     2. Subscriptions to GET requests
     3. Ranges to PUT and PATCH requests
     4. Merge-Types that specify OT or CRDT behavior

   These extensions enable a web resource to synchronize automatically
   across multiple clients, servers and caches, and guarantee
   consistency using a OT, CRDT, or other algorithm.



Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as
   Internet-Drafts.  The list of current Internet-Drafts is at
   http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   https://www.ietf.org/1id-abstracts.html

   The list of Internet-Draft Shadow Directories can be accessed at
   https://www.ietf.org/shadow.html



Table of Contents

   1.  Introduction ..................................................4
       1.1.  Design Goals ............................................5
       1.2.  Use Cases and Related Work ..............................5
          1.2.1.  Example: a Serverless Chat .........................5
          1.2.2.  Web Frameworks .....................................6
          1.2.3.  Existing IETF Standards ............................7
   2.  Versioning for Resources ......................................7
       2.1.  Comparison with ETag ....................................9
       2.2.  Requesting Historical Versions .........................10
   3.  Subscriptions for GET ........................................11
       3.1.  Creating a Subscription ................................11
       3.2.  Sending multiple updates per GET .......................11
       3.3.  Continuing a Subscription ..............................12
       3.4.  Ending a Subscription ..................................12
       3.5.  Example: GET subscription that animates a GIF ..........13
       3.6.  Errors .................................................13
   4.  Range Patches ................................................14
       4.1.  The Version Data Structure .............................14
       4.2.  Defining a new Patch Type ..............................15
          4.2.1.  Patch Behavior ....................................15
   5.  Merge Types ..................................................16
   6.  IANA Considerations ..........................................16
       6.1. Header Field Registration ...............................16
   7.  Security Considerations ......................................16
   8.  Conventions ..................................................17
   9.  Copyright Notice .............................................17
   10. References ...................................................17
       10.1.  Normative References ..................................17
       10.2.  Informative References ................................18


1.  Introduction

   When a client GETs a resource over HTTP, the server sends the latest
   version, but does not send updates when the resource changes.  If a
   web programmer wants to synchronize with state as it changes, she
   must implement a workaround.

   The web has a long history of these workarounds.  The original web
   required users to click reload when a page changed.  XMLHTTPRequest
   [XHR] made it possible to update just part of a page, running a GET
   request behind the scenes.  However, a GET request still could not
   push updates.  To work around this, web programmers would poll the
   resource, which was inefficient.  Long-polling was invented to
   overcome the inefficiencies, which was standardized as Server-Sent
   Events [SSE].  Yet, SSE provides semantics of an event-stream, not an
   update-stream, and although a programmer can encode a protocol within
   the event stream for updating a resource, there is still no standard
   way to express the update of a resource.

   In practice, web programmers today often give up on using standards
   for "data that changes", and instead send custom messages over a
   WebSocket -- a hand-rolled synchronization protocol.  Unfortunately,
   this forfeits the benefits of HTTP and ReST, such as caching, and a
   uniform interface [REST].  As the web becomes increasingly dynamic,
   programmers must increasingly synchronize state, rather than simply
   transfer it with HTTP.

   Braid extends HTTP into a synchronization protocol.  It adds these
   features:

     1. Versioning (Section 2)

        Each resource has a history of changes, ordered in time.

     2. Subscriptions (Section 3)

        A client can add a Subscribe header to a GET request, which will
        subscribe it to all future versions of the resource until the
        client says forGET.

     3. Range Patches [RANGE-PATCH]

        When a resource changes, a client, server, or cache can send
        just the changed range, rather than the entire resource.  This
        extends the existing HTTP Range Request with semantics for PUT,
        PATCH, and POST.

     4. Merge Types [MERGE-TYPES]

        If multiple clients and servers simultaneously edit the same
        resource, they can guarantee a consistent resulting state by
        implementing the same Merge Type.  Resources specify their Merge
        Type with a header.


   Taken together, these features allow an arbitrary set of clients and
   servers to make arbitrary edits to resources, under arbitrary network
   delays and paritions, and merge all edits consistently, receiving
   updates as soon as they reconnect.  This enables caches to support
   dynamic content, web applications to feature an offline mode, and
   textareas to support collaborative editing.


1.1.  Design Goals

   This spec is designed to be:

   1. Backwards-compatible with existing HTTP

   2. Easy to implement simple synchronizers with.  For instance, it
      should be easy to write a read-only synchronizer for an
      append-only log.

   3. Possible to implement arbitrary synchronization algorithms.  For
      instance, these extensions support any Operational Transform or
      CRDT algorithm.

1.2.  Use Cases and Related Work

1.2.1.  Example: a Serverless Chat

   A Braid web application can operate offline.  A user can use the app
   from an airplane, and their edits can synchronize when they regain
   internet connections.  Additionally, the Braid protocol can be
   expressed over peer-to-peer transports (e.g. Braid-WebRTC) to support
   a peer-to-peer synchronization without a server.  Braid-HTTP clients
   will be able to interoperate with Braid-WebRTC peers.  For example, a
   chat application might be served and synchronized on Braid-HTTP,
   while also establishing redundant peer-to-peer connections on
   Braid-WebRTC.  The server could then be shut down, and users of the
   chat app could continue to send messages to one another.

   Imagine the server serves the current set of trusted clients' IP
   addresses at the /peers state.  Each client then subscribes to the
   /peers state with:

     GET /peers
     Subscribe: keep-alive
     -------
     [ {ip: '13.55.32.158', pubkey: 'x371...8382'},
       {ip: '244.38.55.83', pubkey: 'o2u8...2s73'},
       ...
     ]

   Each peer can then choose a set of those peers with whom to establish
   a WebRTC connection.  It will then exchange Braid messages with those
   peers over that connection.



1.2.2.  Web Frameworks

   Web applications typically synchronize the state of a client and
   server with layers of models, views, and controllers in web
   frameworks.  By implementing synchronization in HTTP, programmers
   have to write fewer layers of code.

      ====== Legacy Websites ======      ====== Braid Websites ======

      Today's webpages are               Braid generalizes HTTP and
      generated from multiple            into a standard for
      layers of state.  Each layer       synchronizing state within
      has a different API.               and between websites.

        x Non-standard state API          o Standard state API

        _Client__
       /         \
      :  o o o o  :   Webpage DOM          o o o o       State
      :   \|  \|  :                         \|  \|
      :    x   x  :   HTML Templates         o   o       State
      :   /|  /|  :                         /|  /|
      :  x x x x  :   JS Models            o o o o       State
       \ | | | | /                         | | | |
         | | | |                           | | | |
         o o o o    - http:// -            o o o o     - http:// -
       / | | | | \                         | | | |
      :  x x x x  :   Views                o o o o       State
      :  |  \| |  :                        |  \| |
      :  x   x x  :   Controllers          o   o o       State
      :   \ / \|  :                         \ / \|
      :    x   x  :   Models                 o   o       State
      :     \ /   :                           \ /
       \.... x ../    Database                 o         State
         Server

      Today's programmers have to        Each piece of Braid state (o)
      learn each API, and wire them      has a URL; whether public or
      together, making sure that         internal.  State can be a
      changes to shared state            function of other state, and
      synchronize across all             and automatically recompute
      layers and computers.              when its dependencies change.
                                         Braid guarantees network
                                         synchronization.




1.2.3.  Existing IETF Standards

   A number of IETF specifications already standardize aspects of
   synchronization for specific domains.  IMAP [RFC3501] provides
   synchronization of email.  WebDAV provides the synchronization of
   "collections" [RFC6578], and has been extended specifically for
   calendar data in CalDAV [RFC4791], and vCards in [RFC6350].  More
   recently, JMAP [RFC8620] provides an updated method of
   synchronization, supporting mail, calendars, and contacts.

2.  Versioning of Resources

   Each Braid resource has a version history.  Versions are specified
   with a unique string in the [STRUCTURED-HEADERS] format.  A Version
   header MAY be included in a request for a PUT, PATCH or POST, or in
   the response to a GET:

           Version: "dkn7ov2vwg"

   Every version also has a set of Parents, which denote the most recent
   Version(s) that were known at the time the version was created.  The
   full graph of parents forms a Directed Acyclic Graph (DAG),
   representing the known partial order of all versions.  A version A is
   known to have occurred before a version B if and only if A is an
   ancestor of B in the partial order.

   Parents are also specified using a header in a PUT, PATCH, or POST
   request, and a GET response:

           Parents: "ajtva12kid", "cmdpvkpll2"

   The Parents header MUST be of type List in [STRUCTURED-HEADERS], with
   each element a string obeying the requirements of a Version.  For any
   two parent versions A and B that are specified in a Parents header, A
   cannot be a descendent of B or vice versa.

   If a client or server does not specify a Version for a resource it
   transfers, the recipient MAY generate a new version ID of its own
   choosing.  If a client or server does not specify a Parents header
   when transferring a new version, the recipient MAY presume that the
   most recent versions it has seen are the parents of the new version.

2.1.  Comparison with ETag

   The Version header is similar to an ETag, but has two differences:

   1. ETags are sensitive to Content-Encoding.  If you send the same
      version with a GZip Content-Encoding, it will have a different
      ETag, but the same Version.

   2. A Version marks a unique point in time -- not unique content.  If
      a resource is changed from version A to B, and then to C, such
      that the contents at A are the same as the contents at C, then it
      is possible versions A and C to have the same ETag, even though
      they have different Versions.


2.2.  Requesting Historical Versions

   A server can optionally allow clients to request historical versions
   of a resource in GET requests.  To request a historical version, a
   client includes a Version and/or Parents header in the request.

   If a GET request contains a Version header:

   - The Subscribe header (Section 3) MUST be absent.

   - The server SHOULD return a single response, containing that version
     of the resource in its body, with the Version header set to the
     version requested by the client.

   - If the server does not support historical versions, it MAY ignore
     the Version header and respond as usual, but MUST NOT include the
     Version header in its response.

   If a GET request contains a Parents header:

   - If the request does not also contain a Version, then the request
     MUST also contain a Subscribe header, and the server SHOULD send a
     set of versions connecting the Parents to the current Version, and
     then subscribe the client to future updates.

   - If the request also contains a Version, then the server SHOULD
     respond with a set of versions that connect the specified Parents
     with the specified Version, and then close the connection.

   - If the server does not support historical versions, then it MAY
     ignore the Parents header, but MUST NOT include the Parents header
     in its response.

   A server MAY refactor or rebase the version history that it provides
   to a client, so long as it does not affect the resulting state, or
   the result of the patch-type's merges.



3.  Subscriptions for GET

3.1.  Creating a Subscription

   The "Subscribe" header on a GET request modifies the method semantics
   to request a subscription to future updates to the data, rather than
   only the current version of the representation data.

   A client MAY request a subscription by issuing a GET request
   containing a Subscribe header:

           Subscribe
      or   Subscribe: keep-alive
      or   Subscribe: keep-alive=<seconds>

   If a server implements Subscribe, it MUST include a Subscribe header
   in its response.  The server then SHOULD keep the connection open,
   and send updates over it.

   In general, a server that implements subscriptions promises to keep
   its subscribed clients up-to-date by sending changes until the client
   closes the subscription.  A subscription is different from a GET
   connection (e.g. a TCP connection, or HTTP/2 stream).  If a client
   requests "Subscribe: keep-alive", then the subscription will be
   remembered even after the GET connection closes.  A subscription can
   be resumed by the client issuing another GET with a Subscribe header.

3.2.  Sending multiple updates per GET

   To send multiple updates, a server concatenates multiple
   sub-responses into a single response body.  Each sub-response MUST
   contain its own headers and body.  Each sub-response's headers MUST
   contain a

      Content-Length: N

   header, where N is specified in bytes.  The sub-response body MUST be
   exactly N bytes, and be followed with a single newline.  Any data
   after this newline begins the next sub-response's header.

   Each response MUST have both headers and a body.  The body MAY be
   zero-length.



3.3.  Continuing a Subscription

   Even if a connection closes, a subscription might still be active.
   If a server's response headers for a connection contained:

           Subscribe: keep-alive
      or   Subscribe: keep-alive=<seconds>

   Then the server SHOULD keep the subscription open even after the
   connection closes.  This means that the server promises to keep
   enough history to merge with the client when the client comes back
   online.

   When the client reconnects, it MAY specify the most recent versions
   it saw from the server using the Parents header (Section 3).  This
   tells the server which versions of state to catch it up from.

   The server can suggest how long it will wait for the client by
   responding with Subscribe: keep-alive=<seconds>.  A server SHOULD
   wait at least <seconds> after a connection closes before dropping the
   subscription, and clearing its history.

3.4.  Ending a Subscription

   Servers and clients MAY drop a subscription at any time, no matter
   the value of keep-alive.  A client MAY reconnect by issuing a new GET
   request with a new Subscribe header.

   If a subscription is set to keep-alive, then closing the TCP/QUIC
   connection won't end the subscription.  Thus a client needs a way to
   explicitly end the subscription.  In HTTP/1, this is by sending the
   text "forGET\n" over the TCP connection.  In HTTP/2, this is by
   issuing a CLOSE event to the GET request's stream.  Alternatively,
   since today's web browsers do not support sending extra text after a
   request body, the client can issue a fresh request specified as a
   FORGET method.



3.5.  Example: GET subscription that animates a GIF

   In this example, a server streams changes to a GIF file in a sequence
   of patches.  When the client renders the new state of the GIF after
   each patch, a new frame of animation is displayed.

     Request:
       GET /animated-braid.gif
       Subscribe

     Response:
       HTTP/1.1 200 OK
       Subscribe
       Cache-Control: no-cache, patch
       Patch-Type: braid(bytes, sync9(array))

       Content-Type: image/gif                             -- Frame 1
       Patch-Type: braid(bytes, sync9(array))
       Content-Length: 1239

       [100:200] = <binary data>

       Content-Type: image/gif                             -- Frame 2
       Patch-Type: braid(bytes, sync9(array))
       Content-Length: 62638

       [348:887] = <binary data>

3.6.  Errors

   If a server decides has dropped the history that a client requests,
   the server can return a 410 GONE response, to tell the client "sorry,
   I don't have the history necessary to synchronize with you."



4.  Range Patches

4.1.  The Version Data Structure

   A client SHOULD send a new version in a PATCH, POST, or PUT request.
   A server MAY send a version in the response or sub-response to a GET
   request.  A version MAY contain any combination of the following
   headers, with one restriction:

     Patch-Type: <patch-type>
     Cache-Control: no-cache, patch
     Version: <versionid>
     Parents: <versionid>, <versionid>, ...

   The restriction is that if Patch-Type is present, then the body
   contains a patch, and the response MUST also specify Cache-Control:
   no-cache, patch, to ensure that legacy systems do not cache the patch
   as if it were the resource.

   - If Patch-Type is not specified, or Cache-Control does not have
     no-cache, then the request or response body SHOULD be interpreted
     as a complete representation of the resource.

   - If the Version header is not specified, then the recipient MAY
     invent a new version ID for it, and MAY use that new ID in network
     communications with others.

   - If the Parents is not specified, then the recipient SHOULD
     interpret the version to be new, built upon the latest versions
     the recipient has.  The determination of which versions are
     "latest" is up to the recipient.



4.2.  Defining a new Patch Type

   A human MAY define a patch type by publishing a specification of its:

     - Patch-Type

     - Data format

     - and Behavior: the outcome after applying a sequence of patches to
       - set of versions.

   The Patch-Type is an arbitrary string, such as:

     Patch-Type: braid
     Patch-Type: automerge/json
     Patch-Type: sharedb/rich-text

   The Content-Type SHOULD start with patch/*, such as:

     Content-Type: patch/braid
     Content-Type: patch/automerge/json
     Content-Type: patch/sharedb/rich-text

   A patch/* content-type indicates that the content is a type of patch
   that satisfies the requirements of this section.

4.2.1.  Patch Behavior

   A patch SHOULD satisfy:

   - If a set of patches originated from a version, and you apply them
     to a copy of the version, you get the same new version again.

   A patch MAY satisfy:

   - (Commute) If the same set of patches are applied in a different
     order, the result is the same.



5.   Merge Types

   Merge Types specify how to merge multiple simultaneous edits to a
   resource consistently.  This typically happens if two computers edit
   the same state over a network with latency.  If the computers
   implement and agree upon the same Merge Type, then they can guarantee
   to reach a consistent state, after arbitrary edits, eventually.

   Merge Types are discussed in a separate document, [MERGE-TYPES].


6. IANA Considerations

6.1.  Header Field Registration

   HTTP header fields are registered within the "Message Headers"
   registry maintained at
   <http://www.iana.org/assignments/message-headers/>.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [BCP90]):

   +---------------------+----------+--------------+-------------+
   | Header Field Name   | Protocol | Status       | Reference   |
   +---------------------+----------+--------------+-------------+
   | Version             | http     | experimental | Section 2.2 |
   | Parents             | http     | experimental | Section 2.2 |
   | Subscribe           | http     | experimental | Section 2.2 |
   +---------------------+----------+--------------+-------------+

   The change controller is: "IETF (iesg@ietf.org) - Internet
   Engineering Task Force".


7. Security Considerations

   XXX Todo



8.  Conventions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

9.  Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

10.  References

10.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.
   
   [MERGE-TYPES] draft-toomim-httpbis-merge-types-00

   [RANGE-PATCH] draft-toomim-httpbis-range-patch-00

   [STRUCTURED-HEADERS] draft-ietf-httpbis-header-structure-14




10.2.  Informative References

   [XHR]      Van Kestern, A., Aubourg, J., Song, J., and R. M.
              Steen, H.  "XMLHttpRequest", September 2019.
              <https://xhr.spec.whatwg.org/>

   [SSE]      Hickson, I.  "Server-Sent Events", W3C Recommendation,
              February 2015.
              <https://www.w3.org/TR/2015/REC-eventsource-20150203/>

   [REST]     Fielding, R.  "Architectural Styles and the Design of
              Network-based Software Architectures"  Doctoral
              dissertation, University of California, Irvine, 2000.

   [RFC3501]  Crispin, M.,  "Internet Message Access Protocol - Version
              4rev1", RFC 3501, DOI 10.17487/RFC3501, March 2003,
              <https://www.rfc-editor.org/info/rfc3501>.

   [RFC6578]  Daboo, C., Quillaud, A., "Collection Synchronization
              for Web Distributed Authoring and Versioning (WebDAV)",
              RFC 6578, DOI 10.17487/RFC6578, March 2012,
              <https://www.rfc-editor.org/info/rfc6578>.

   [RFC4791]  Daboo, C., Desruisseaux, B., Dusseault, L., "Calendaring
              Extensions to WebDAV (CalDAV)", RFC 4791,
              DOI 10.17487/RFC4791, March 2007,
              <https://www.rfc-editor.org/info/rfc4791>.

   [RFC6350]  Perreault, S., "vCard Format Specification", RFC 6350,
              DOI 10.17487/RFC6350, August 2011,
              <https://www.rfc-editor.org/info/rfc6350>.

   [RFC8620]  Jenkins, N., Newman, C., "The JSON Meta Application
              Protocol (JMAP)", RFC 8620, DOI 10.17487/RFC8620,
              July 2019, <https://www.rfc-editor.org/info/rfc8620>.

   [BCP90]    Klyne, G., Nottingham, M., and J. Mogul, "Registration
              Procedures for Message Header Fields", BCP 90, RFC 3864,
              September 2004.


Authors' Addresses

   For more information, the authors of this document are best contacted
   via Internet mail:

   Michael Toomim
   Invisible College, Berkeley
   2053 Berkeley Way
   Berkeley, CA 94704

   EMail: toomim@gmail.com
   Web:   https://invisible.college/@toomim

   Greg Little
   Invisible College, Berkeley
   2053 Berkeley Way
   Berkeley, CA 94704

   EMail: glittle@gmail.com
   Web:   https://glittle.org/

   Rafie Walker
   Bard College

   EMail: slickytail.mc@gmail.com

   Bryn Bellomy
   Invisible College, Berkeley
   2053 Berkeley Way
   Berkeley, CA 94704

   EMail: bryn@signals.io
   Web:   https://invisible.college/@bryn
