Internet-Draft                                                 M. Toomim
Expires: Mar 8, 2020                                   Invisible College
Intended status: Proposed Standard                             G. Little
                                                       Invisible College
                                                               R. Walker
                                                            Bard College
                                                              B. Bellomy
                                                       Invisible College
                                                             Nov 4, 2019

        \=/====\\  |//===\\=      /=\     =\==\|\=/== =|====\==
        ||/    |\\ ||\    |\\   /|| \|\       |//     //|    \\\
        |\\    |// |\\    |//  //|   \\\      \\\     /\/    |||
        \=|====|=  |/====/=\  /=\/====|=\     =\=     \\=    =/=
        //\    /\\ //|    |\\ |/|     |||     \\\     |||    |//
        |||    ||| |\\    |// |\/     \|/     /|\     |=\    |\\
        =\=\==/=/  ==|    |\= ||=     /== ===/=|=\=== |==\===//

                  Braid-HTTP: Synchronization for HTTP
                   draft-toomim-httpbis-braid-http-00

Abstract

   Braid is a set of extensions to HTTP that transform it from a state
   transfer protocol into a state synchronization protocol.

   Braid adds to HTTP:

     1. Versioning to resources
     2. Subscriptions to GET requests
     3. Ranges to PUT and PATCH requests
     4. Merge-Types to specify OT or CRDT behavior

   These extensions enable a web resource to synchronize automatically
   across multiple clients and servers, and guarantee consistency using
   a OT or CRDT algorithm.



Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as
   Internet-Drafts.  The list of current Internet-Drafts is at
   http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   https://www.ietf.org/1id-abstracts.html

   The list of Internet-Draft Shadow Directories can be accessed at
   https://www.ietf.org/shadow.html



Table of Contents

   1.  Introduction ..................................................4
       1.1.  In Visual Infomercial Form ..............................5
       1.2.  Design Goals ............................................6
       1.3.  Use Cases and Related Work ..............................6
          1.3.1. Example: a Serverless Chat ..........................7
   2.  Versioning for Resources ......................................8
       2.1.  Interpreting Versions ...................................8
       2.2.  GET for Historical Versions .............................9
   3.  Subscriptions for GET ........................................10
       3.1.  Creating a Subscription ................................10
       3.2.  Sending multiple updates per GET .......................10
       3.3.  Continuing a Subscription ..............................11
       3.4.  Ending a Subscription ..................................11
       3.5.  Example: GET subscription that animates a GIF ..........12
       3.6.  Errors .................................................12
   4.  Range Patches ................................................13
       4.1.  The Version Data Structure .............................13
       4.2.  Defining a new Patch Type ..............................14
          4.2.1.  Patch Behavior ....................................14
   5.  Merge Types ..................................................15
   6.  IANA Considerations ..........................................15
       6.1. Header Field Registration ...............................15
   7.  Security Considerations ......................................15
   8.  Conventions ..................................................16
   9.  Copyright Notice .............................................16
   10. References ...................................................16
       10.1.  Normative References ..................................16
       10.2.  Informative References ................................17



1.  Introduction

   When a client GETs a resource over HTTP, the server sends the latest
   version, but HTTP does not send updates when the resource changes.
   This means web programmers have to implement a workaround whenever
   they need to synchronize with data that changes.

   The web has a long history of these workarounds.  The original web
   required users to click reload when a page changed.  In 2000,
   XMLHTTPRequest made it possible to update just part of a page,
   running a GET request behind the scenes.  But a GET request still
   could not push updates.  To work around this, web programmers would
   poll the resource, which was inefficient.  Long-polling was invented
   to overcome the inefficiencies, which was standardized as SSE.  But
   SSE provides semantics of an event-stream, not an update-stream, and
   although a programmer can encode a protocol within the event stream
   for updating a resource, there is still no standard way to express
   the update of a resource.  In practice, programmers today often give
   up on using standards for "data that changes", and instead write
   their own non-standard update protocol over a WebSocket.

   Unfortunately, non-standard protocols require extra time and effort
   to design and implement, and programmers often implement only the
   minimal synchronization features they need.  Thus, most web apps do
   not have an offline mode, or guarantee consistency after conflicting
   edits over a network.  Programmers often do not bother to implement a
   public API, or to keep it as featureful as the private one.  These
   frictions lead to it being much easier for a programmer to read and
   write data from their database than from some other website's
   database, and as a result, programmers tend to build websites in
   silos, where each one grows and controls data only within its own
   domain.

   The Braid extensions solve these problems with a standard protocol
   for synchronizing changing state.  Each piece of state gets a URL.
   Each URL gets a DAG of historical versions.  GET requests can
   optionally Subscribe to future updates, until issuing FORGET.
   Updates get a standard patch format.  Merge semantics guarantee
   eventual consistency over a peer-to-peer network.  Clients and
   servers can go offline, make edits on airplanes, and then merge all
   edits perfectly when they rejoin.



1.1.  In Visual Infomercial Form

      ====== Legacy Websites ======      ====== Braid Websites ======

      Today's webpages are               Braid generalizes HTTP and
      generated from multiple            REST into a uniform standard
      layers of state.  Each layer       that synchronizes state
      has a different API.               within and between dynamic
                                         websites.

        x Non-standard state API          o Standard state API

        _Client__
       /         \
      :  o o o o  :   Webpage DOM          o o o o       State
      :   \|  \|  :                         \|  \|
      :    x   x  :   HTML Templates         o   o       State
      :   /|  /|  :                         /|  /|
      :  x x x x  :   JS Models            o o o o       State
       \ | | | | /                         | | | |
         | | | |                           | | | |
         o o o o    - http:// -            o o o o     - http:// -
       / | | | | \                         | | | |
      :  x x x x  :   Views                o o o o       State
      :  |  \| |  :                        |  \| |
      :  x   x x  :   Controllers          o   o o       State
      :   \ / \|  :                         \ / \|
      :    x   x  :   Models                 o   o       State
      :     \ /   :                           \ /
       \.... x ../    Database                 o         State
         Server

      Today's programmers have to        Each piece of Braid state (o)
      learn each API, and wire them      has a URL; whether public, or
      together, making sure that         internal to a client or
      changes to shared state            server.  Any state can be a
      synchronize across all             function of other state, and
      layers and computers.              and automatically recompute
                                         when its dependencies change.
                                         Braid guarantees network
                                         synchronization.


1.2.  Design Goals

   This spec is designed to be:

   1. Backwards-compatible with existing HTTP

   2. Easy to implement simple synchronizers with.  For instance, easy
      to create an append-only log, or a counter.

      - EXAMPLE: A complete braid client for an append-only log can be
        written in 50 lines of Javascript, without using any libraries.

   3. Possible to implement arbitrary synchronization algorithms.  For
      instance, these extensions support any Operational Transform or
      CRDT algorithm.

1.3.  Use Cases and Related Work

   A number of IETF specifications already standardize aspects of
   synchronization for specific domains:

   - The DAV standards:
     - CalDAV
     - CardDAV
     - WebDAV
   - W3C Push API:
     - https://www.w3.org/TR/push-api/
   - Email push
     - JMAP
     - IMAP Web Push

   Each of these standards has to re-invent mechanisms for (a)
   specifying subscriptions, (b) pushing updates, and (c) specifying
   patches, and (d) handling conflicts.



1.3.1.  Example: a Serverless Chat

   A Braid web application can operate offline.  Multiple users can use
   the app from an airplane, and their edits can synchronize when they
   regain internet connections.  Additionally, the Braid protocol can be
   expressed over peer-to-peer transports (e.g. Braid-WebRTC) to support
   a peer-to-peer synchronization without a server.  Braid-HTTP clients
   will be able to interoperate with Braid-WebRTC peers.  For example,
   a chat application might be served and synchronized on Braid-HTTP,
   while also establishing redundant peer-to-peer connections on
   Braid-WebRTC.  The server could then be shut down, and users of the
   chat app could continue to send messages to one another.

   Imagine the server serves the current set of trusted clients' IP
   addresses at the /peers state.  Each client then subscribes to the
   /peers state with:

     GET /peers
     Subscribe: keep-alive
     -------
     [ {ip: '13.55.32.158', pubkey: 'x371...8382'},
       {ip: '244.38.55.83', pubkey: 'o2u8...2s73'},
       ...
     ]

   Each peer can then choose a set of those peers with whom to establish
   a WebRTC connection.  It will then exchange Braid messages with those
   peers over that connection.



2.  Versioning of Resources

   Patches change the state of a resource over time.  We define a
   "Version" as a point in time.  At a particular version, the contents
   of a particular resource is immutable -- it will never change.  Each
   version has a unique ID (a string), and a set of patches from its
   prior versions: its Parents.

      Version: a unique string identifying a point in time
      Parents: a set of Version IDs

   A Version can have multiple Parents because time on a network is a
   DAG, due to the unavoidable presence of network latency.  It can be
   physically impossible to distinguish the order of two events that
   occur close in time.  Thus, the general form of time on a network is
   a Directed Acyclic Graph.

         a     All peers are aware of version (a).
        / \
       /   \
      b     c  Two peers make simultaneous edits creating versions (b)
       \   /   and (c) respectively, and time forks.
        \ /
         d     Once a peer sees both of the edits, time merges again.
               Until a peer makes an edit with (b) and (c) as parents,
               the merge is only implicit-- there is no need for to
               assign an ID to it.

   Every change to state creates a new version.  This version has
   Parents: the set of leaves in the DAG that were present when the new
   version was created.  The new version is the Child of its parents.
   We can say that one version came before another only if the first
   version is an Ancestor of the second.

   A Version also specifies a list of Patches, which, when applied to
   the merger of Parents, creates the Version's state.

   When a peer makes an edit, it broadcasts the edit's version ID, its
   parents version IDs, and the patches from its parents state to its
   state.

2.1.  Interpreting Versions

   Versions need their parents to be understood.



2.2.  GET for Historical Versions

   GET requests can optionally contain a Version and/or Parents header.

   If a GET request contains a Version header:

   - The Subscribe header MUST be absent.

   - The server SHOULD return a single response, containing that version
     of the resource in its body.

   If a GET request contains a Parents header:

   - If the request does not also contain a Version, then the request
     MUST also contain a Subscribe header, and the server SHOULD send a
     set of versions connecting the Parents to the current Version, and
     then subscribe the client to future updates.

   - If the request also contains a Version, then the server SHOULD
     respond with a set of versions that connect the specified Parents
     with the specified Version, and then close the connection.

   A server MAY refactor or rebase the version history that it provides
   to a client, so long as it does not affect the resulting state, or
   the result of the patch-type's merges.

   Note that the 'Version' header is similar to, but not the same as the
   'ETag' header, because an ETag depends on the Content-Encoding.  For
   instance, the same resource sent using gzip Content-Encoding will
   have a different ETag, but the same Version.



3.  Subscriptions for GET

3.1.  Creating a Subscription

   The "Subscribe" header on a GET request modifies the method semantics
   to request a subscription to future updates to the data, rather than
   only the current version of the representation data.

   A client MAY request a subscription by issuing a GET request
   containing a Subscribe header:

           Subscribe
      or   Subscribe: keep-alive
      or   Subscribe: keep-alive=<seconds>

   If a server implements Subscribe, it MUST include a Subscribe header
   in its response.  The server then SHOULD keep the connection open,
   and send updates over it.

   In general, a server that implements subscriptions promises to keep
   its subscribed clients up-to-date by sending changes until the client
   closes the subscription.  A subscription is different from a GET
   connection (e.g. a TCP connection, or HTTP/2 stream).  If a client
   requests "Subscribe: keep-alive", then the subscription will be
   remembered even after the GET connection closes.  A subscription can
   be resumed by the client issuing another GET with a Subscribe header.

3.2.  Sending multiple updates per GET

   To send multiple updates, a server concatenates multiple
   sub-responses into a single response body.  Each sub-response MUST
   contain its own headers and body.  Each sub-response's headers MUST
   contain a

      Content-Length: N

   header, where N is specified in bytes.  The sub-response body MUST be
   exactly N bytes, and be followed with a single newline.  Any data
   after this newline begins the next sub-response's header.

   Each response MUST have both headers and a body.  The body MAY be
   zero-length.



3.3.  Continuing a Subscription

   Even if a connection closes, a subscription might still be active.
   If a server's response headers for a connection contained:

           Subscribe: keep-alive
      or   Subscribe: keep-alive=<seconds>

   Then the server SHOULD keep the subscription open even after the
   connection closes.  This means that the server promises to keep
   enough history to merge with the client when the client comes back
   online.

   When the client reconnects, it MAY specify the most recent versions
   it saw from the server using the Parents header (Section 3).  This
   tells the server which versions of state to catch it up from.

   The server can suggest how long it will wait for the client by
   responding with Subscribe: keep-alive=<seconds>.  A server SHOULD
   wait at least <seconds> after a connection closes before dropping the
   subscription, and clearing its history.

3.4.  Ending a Subscription

   Servers and clients MAY drop a subscription at any time, no matter
   the value of keep-alive.  A client MAY reconnect by issuing a new GET
   request with a new Subscribe header.

   If a subscription is set to keep-alive, then closing the TCP/QUIC
   connection won't end the subscription.  Thus a client needs a way to
   explicitly end the subscription.  In HTTP/1, this is by sending the
   text "Forget\n" over the TCP connection.  In HTTP/2, this is by
   issuing a CLOSE event to the GET request's stream.  Alternatively,
   since today's web browsers do not support sending extra text after a
   request body, the client can issue a fresh request specified as a
   FORGET method.



3.5.  Example: GET subscription that animates a GIF

   In this example, a server streams changes to a GIF file in a sequence
   of patches.  When the client renders the new state of the GIF after
   each patch, a new frame of animation is displayed.

     Request:
       GET /animated-braid.gif
       Subscribe

     Response:
       OK 200
       Subscribe
       Cache-Control: no-cache, patch
       Patch-Type: braid(bytes, sync9(array))

       Content-Type: image/gif                             -- Frame 1
       Patch-Type: braid(bytes, sync9(array))
       Content-Length: 1239

       [100:200] = <binary data>

       Content-Type: image/gif                             -- Frame 2
       Patch-Type: braid(bytes, sync9(array))
       Content-Length: 62638

       [348:887] = <binary data>

3.6.  Errors

   If a server decides has dropped the history that a client requests,
   the server can return a 410 GONE response, to tell the client "sorry,
   I don't have the history necessary to synchronize with you."



4.  Range Patches

4.1.  The Version Data Structure

   A client SHOULD send a new version in a PATCH, POST, or PUT request.
   A server MAY send a version in the response or sub-response to a GET
   request.  A version MAY contain any combination of the following
   headers, with one restriction:

     Patch-Type: <patch-type>
     Cache-Control: no-cache, patch
     Version: <versionid>
     Parents: <versionid>, <versionid>, ...

   The restriction is that if Patch-Type is present, then the body
   contains a patch, and the response MUST also specify Cache-Control:
   no-cache, patch, to ensure that legacy systems do not cache the patch
   as if it were the resource.

   - If Patch-Type is not specified, or Cache-Control does not have
     no-cache, then the request or response body SHOULD be interpreted
     as a complete representation of the resource.

   - If the Version header is not specified, then the recipient MAY
     invent a new version ID for it, and MAY use that new ID in network
     communications with others.

   - If the Parents is not specified, then the recipient SHOULD
     interpret the version to be new, built upon the latest versions
     the recipient has.  The determination of which versions are
     "latest" is up to the recipient.



4.2.  Defining a new Patch Type

   A human MAY define a patch type by publishing a specification of its:

     - Patch-Type

     - Data format

     - and Behavior: the outcome after applying a sequence of patches to
       - set of versions.

   The Patch-Type is an arbitrary string, such as:

     Patch-Type: braid
     Patch-Type: automerge/json
     Patch-Type: sharedb/rich-text

   The Content-Type SHOULD start with patch/*, such as:

     Content-Type: patch/braid
     Content-Type: patch/automerge/json
     Content-Type: patch/sharedb/rich-text

   A patch/* content-type indicates that the content is a type of patch
   that satisfies the requirements of this section.

4.2.1.  Patch Behavior

   A patch SHOULD satisfy:

   - If a set of patches originated from a version, and you apply them
     to a copy of the version, you get the same new version again.

   A patch MAY satisfy:

   - (Commute) If the same set of patches are applied in a different
     order, the result is the same.



5.   Merge Types

   Merge Types specify how to merge multiple simultaneous edits to a
   resource consistently.  This typically happens if two computers edit
   the same state over a network with latency.  If the computers
   implement and agree upon the same Merge Type, then they can guarantee
   to reach a consistent state, after arbitrary edits, eventually.

   Merge Types are discussed in a separate document, [MERGETYPES].


6. IANA Considerations

   6.1.  Header Field Registration

   HTTP header fields are registered within the "Message Headers"
   registry maintained at
   <http://www.iana.org/assignments/message-headers/>.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [BCP90]):

   +---------------------+----------+--------------+-------------+
   | Header Field Name   | Protocol | Status       | Reference   |
   +---------------------+----------+--------------+-------------+
   | Version             | http     | experimental | Section 2.2 |
   | Parents             | http     | experimental | Section 2.2 |
   | Subscribe           | http     | experimental | Section 2.2 |
   +---------------------+----------+--------------+-------------+

   The change controller is: "IETF (iesg@ietf.org) - Internet
   Engineering Task Force".


7. Security Considerations

   XXX Todo



8.  Conventions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

9.  Copyright Notice

   Copyright (c) 2019 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

10.  References

10.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [MERGETYPES] draft-toomim-httpbis-merge-types-00



10.2.  Informative References



Authors' Addresses

   For more information, the authors of this document are best contacted
   via Internet mail:

   Michael Toomim
   Invisible College, Berkeley
   2053 Berkeley Way
   Berkeley, CA 94704

   EMail: toomim@gmail.com
   Web:   https://invisible.college/@toomim

   Greg Little
   Invisible College, Berkeley
   2053 Berkeley Way
   Berkeley, CA 94704

   EMail: glittle@gmail.com
   Web:   https://glittle.org/

   Rafie Walker
   Bard College

   EMail: slickytail.mc@gmail.com

   Bryn Bellomy
   Invisible College, Berkeley
   2053 Berkeley Way
   Berkeley, CA 94704

   EMail: bryn@signals.io
   Web:   https://invisible.college/@bryn
